"""Provision resources model representation"""
# -*- coding: utf-8 -*-
from __future__ import annotations
from datetime import datetime
from stackmate.base import Model, ModelAttribute, AttributeDict
from stackmate.helpers import diff_dictionaries


class Resource(Model):
    """Represents a deployment resource"""
    _provision_params = ModelAttribute(required=True, datatype=dict)
    _group = ModelAttribute(required=True, datatype=dict)
    _reference = ModelAttribute(required=False, datatype=str)
    _tainted = ModelAttribute(required=True, default=False, datatype=bool)
    _touched = ModelAttribute(required=True, default=False, datatype=bool)
    _id = ModelAttribute(required=False, datatype=str)
    _created_at = ModelAttribute(required=False, datatype=str)
    _output = ModelAttribute(required=False, default={}, datatype=dict)

    def __init__(self, **kwargs):
        self.tainted = False
        self.touched = False
        self.__output = {}

        group = kwargs.pop('group')
        provision_params = kwargs.pop('provision_params', {})

        super().__init__(group=group, provision_params=provision_params or {}, **kwargs)

    @property
    def output(self):
        """Returns the output generated by our ansible module"""
        return self.__output

    @output.setter
    def output(self, output):
        self.__output = AttributeDict(output or {})

    def taint(self):
        """Marks the resource as tainted (to be removed)"""
        self.tainted = True

    def touch(self):
        """Marks the resource as touched (to be force-modified)"""
        self.touched = True

    def refers_to(self, deployable) -> bool:
        """Returns whether the resource refers to the deployable"""
        return self.id == deployable.deployable_id

    def node_list(self) -> list:
        """Returns the nodes in the output as a list of resources"""
        nodes = self.output.get('nodes', [])
        nodelist = []

        for node in nodes:
            attrs = dict(self.attributes).copy()
            params = dict(self.provision_params).copy()

            params.update({'name': node.get('name')})
            attrs.update({'provision_params': params})

            nodelist.append(Resource(**attrs))

        return nodelist

    def is_identical(self, resource):
        """Checks whether two resources are identical"""
        return self.id == resource.id and self.provision_params == resource.provision_params

    def diff_params(self, other) -> dict:
        """Returns the diff between two resource objects"""
        return diff_dictionaries(self.provision_params, other.provision_params)

class ResourceList:
    """Represents the changes to occur in the deployment resources"""
    def __init__(self, resources=None):
        # sort the resource based on their creation date, newset first
        self._provisions = []
        self._modifications = []
        self._terminations = []
        self._all_resources = []
        self.reset(resources)

    def modify_touched_resources(self):
        """Resources that are touched should be marked as modified (re-deployed)"""
        for res in self._all_resources:
            if res.touched:
                self._modifications.append(res)

    def terminate_unused_resources(self, deployables):
        """
        Processes the resources that should be terminated.
        This includes resources that are orphaned or tainted
        ie. resources that do not refer to any of the deployables in the list
            or explicitly marked as tainted
        """
        for res in self._all_resources:
            is_relevant = any(res.refers_to(dep) for dep in deployables)
            is_tainted = res.tainted

            if is_tainted or not is_relevant:
                self.remove(res)

        return self._terminations

    def find(self, deployable) -> list:
        """Finds the resources that correspond to the deployable"""
        return list([res for res in self._all_resources if res.refers_to(deployable)])

    def find_by_id(self, resource_id) -> Resource:
        """Finds a resource by a given id"""
        return next((res for res in self._all_resources if res.id == resource_id), None)

    def exists(self, deployable):
        """Checks whether a deployable exists in the resource list"""
        return len(self.find(deployable)) > 0

    def provision(self, deployable):
        """Provision a deployable"""
        return self.append(*deployable.as_resources())

    def modify(self, deployable):
        """Modifies resources for a deployable"""
        return self.replace(deployable, *self.find(deployable))

    def terminate(self, deployable):
        """Terminates resources for a deployable"""
        return self.remove(*self.find(deployable))

    def has_changes(self):
        """Returns whether the resources have changed and require provisioning"""
        return any([self._provisions, self._modifications, self._terminations])

    @property
    def all(self) -> list:
        """All of the resources available"""
        return self._all_resources

    def changed(self):
        """Returns the resources that were changed"""
        return self._provisions + self._modifications + self._terminations

    def unchanged(self):
        """Returns the resources that are left unchanged"""
        changed_serialized = [r.serialize() for r in self.changed()]

        return [
            res for res in self._all_resources if res.serialize() not in changed_serialized
        ]

    def reset(self, resources):
        """Add the resources to the list"""
        all_resources = []

        for res in resources or []:
            if not isinstance(res, Resource):
                res = Resource(**res)
            all_resources.append(res)

        self._all_resources = self._sort_resources(all_resources)

    def touch(self, deployable):
        """Marks the resource as touched (to be force-modified)"""
        for res in self.find(deployable):
            res.touch()

    def append(self, *resources):
        """Aads a resource to the list"""
        for resource in resources:
            if not self._provisions or not any(resource.is_identical(r) for r in self._provisions):
                self._all_resources.append(resource)
                self._provisions.append(resource)

        return self._provisions

    def replace(self, deployable, *resources):
        """Modifies a resource on the list"""
        for resource in resources:
            for res in self._all_resources:
                if res.id != resource.id:
                    continue
                res.provision_params = deployable.provision_params

            if not any(resource.is_identical(res) for res in self._modifications):
                self._modifications.append(resource)

        return self._modifications

    def remove(self, *resources):
        """Removes a resource from the list"""
        for resource in resources:
            if not any(resource.is_identical(res) for res in self._terminations):
                self._terminations.append(resource)

        return self._terminations

    def serialize(self) -> dict:
        """Serialize the changeset into a dictionary"""
        return {
            'provisions': self._serialize_resources(self._provisions),
            'modifications': self._serialize_resources(self._modifications),
            'terminations': self._serialize_resources(self._terminations),
            'unchanged': self._serialize_resources(self.unchanged()),
            'has_changes': self.has_changes(),
        }

    @staticmethod
    def _serialize_resources(resources):
        """Serializes the resources"""
        serialized = []
        for resource in resources or []:
            entry = {
                'id': resource.id,
                'group': resource.group,
                'reference': resource.reference,
                'provision_params': resource.provision_params,
                'resource_ids': [],
            }

            if resource.output:
                output = resource.output

                if 'nodes' in output:
                    entry.update({
                        'resource_ids': [
                            n['resource_id'] for n in output['nodes'] if n.get('resource_id')
                        ]
                    })
                elif output.get('resource_id'):
                    entry.update({
                        'resource_ids': [output['resource_id']],
                    })

            serialized.append(entry)

        return serialized

    @staticmethod
    def _sort_resources(resources):
        """Sorts resources in reverse chronological order"""
        return sorted(
            resources,
            key=lambda t: datetime.fromisoformat(str(t.created_at)) if t.created_at else 0,
            reverse=True)

    def __len__(self):
        return len(self._all_resources)

    def __getitem__(self, deployable_id: str):
        return next((res.id == deployable_id for res in self._all_resources), None)

    def __contains__(self, resource: Resource):
        return any(res.id == resource.id for res in self._all_resources)

    def __iadd__(self, otherlist: ResourceList) -> ResourceList:
        self._all_resources += otherlist
        return self
